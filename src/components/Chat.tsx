"use client";

import { useState, useRef, useEffect } from "react";
import { Send, Loader2 } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { chatApi, workoutsApi, Day, User, ChatMessage, Exercise } from "@/lib/client-api";

interface Message {
  id: string;
  text: string;
  isUser: boolean;
  timestamp: Date;
}

interface ChatResponse {
  output: {
    message: string;
    workout_logged: boolean;
    parsed_exercises: Exercise[];
    suggestions: string[];
    next_workout_recommendation: string;
  };
}

interface ChatProps {
  selectedDay: Day | null;
  selectedUser: User;
  onWorkoutSaved?: () => void; // –ö–æ–ª–±–µ–∫ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
}

export function Chat({ selectedDay, selectedUser, onWorkoutSaved }: ChatProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputMessage, setInputMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    loadChatHistory();
  }, [selectedDay]); // eslint-disable-line react-hooks/exhaustive-deps

  const loadChatHistory = async () => {
    if (!selectedDay) {
      setMessages([]);
      setIsInitialized(true);
      return;
    }

    try {
      const chatMessages = await chatApi.getByDay(selectedDay.id);
      
      if (chatMessages.length === 0) {
        // –ï—Å–ª–∏ –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —ç—Ç–æ–≥–æ –¥–Ω—è, –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ
        const dayDate = new Date(selectedDay.date + 'T00:00:00');
        const today = new Date();
        const isToday = selectedDay.date === today.toISOString().split('T')[0];
        
        const dayOfWeek = dayDate.toLocaleDateString('ru-RU', { weekday: 'long' });
        const dayMonth = dayDate.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long' });
        
        let welcomeText;
        if (isToday) {
          welcomeText = `–ü—Ä–∏–≤–µ—Ç! üåü –°–µ–≥–æ–¥–Ω—è ${dayOfWeek}, ${dayMonth}. –ë—É–¥–µ—Ç –ª–∏ —Å–µ–≥–æ–¥–Ω—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞? –†–∞—Å—Å–∫–∞–∂–∏, —á—Ç–æ –ø–ª–∞–Ω–∏—Ä—É–µ—à—å –¥–µ–ª–∞—Ç—å!`;
        } else {
          welcomeText = `–ü—Ä–∏–≤–µ—Ç! üí™ –≠—Ç–æ ${dayOfWeek}, ${dayMonth}. –†–∞—Å—Å–∫–∞–∂–∏, –∫–∞–∫ –ø—Ä–æ—à–ª–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∏–ª–∏ —á—Ç–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–ª –≤ —ç—Ç–æ—Ç –¥–µ–Ω—å?`;
        }
        
        const welcomeMessage = {
          id: "welcome",
          text: welcomeText,
          isUser: false,
          timestamp: new Date(),
        };
        setMessages([welcomeMessage]);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±–∞–∑—É
        await chatApi.create(selectedUser.id, selectedDay.id, welcomeMessage.text, false);
      } else {
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –±–∞–∑—ã –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
        const localMessages: Message[] = chatMessages.map((msg: ChatMessage) => ({
          id: msg.id,
          text: msg.message,
          isUser: msg.is_user,
          timestamp: new Date(msg.timestamp),
        }));
        setMessages(localMessages);
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞:', error);
      setMessages([]);
    } finally {
      setIsInitialized(true);
    }
  };

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const addMessageWithDelay = async (text: string, delay: number) => {
    setTimeout(async () => {
      const newMessage = {
        id: Date.now().toString() + Math.random(),
        text,
        isUser: false,
        timestamp: new Date(),
      };

      setMessages((prev) => [...prev, newMessage]);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±–∞–∑—É
      if (selectedDay) {
        try {
          await chatApi.create(selectedUser.id, selectedDay.id, text, false);
        } catch (error) {
          console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
        }
      }
    }, delay);
  };

  const sendMessage = async () => {
    if (!inputMessage.trim() || isLoading || !selectedDay) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      text: inputMessage.trim(),
      isUser: true,
      timestamp: new Date(),
    };

    setMessages((prev) => [...prev, userMessage]);
    const messageText = inputMessage.trim();
    setInputMessage("");
    setIsLoading(true);

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±–∞–∑—É
    try {
      await chatApi.create(selectedUser.id, selectedDay.id, userMessage.text, true);
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    }

    try {
      console.log("Sending message to webhook:", messageText);
      
      const response = await fetch("/api/webhook", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
        },
        body: JSON.stringify({
          message: messageText,
          user_email: selectedUser.email,
          user_name: selectedUser.name,
        }),
      });

      if (!response.ok) {
        console.error("HTTP error:", response.status, response.statusText);
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data: ChatResponse[] | { output: { message: string; workout_logged?: boolean; parsed_exercises?: Exercise[]; suggestions?: string[] } } = await response.json();
      
      console.log("Full webhook response:", JSON.stringify(data, null, 2));
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ—Ç–≤–µ—Ç–∞ - –º–æ–∂–µ—Ç –±—ã—Ç—å –º–∞—Å—Å–∏–≤ –∏–ª–∏ –æ–±—ä–µ–∫—Ç
      let output = null;
      
      if (data && Array.isArray(data) && data.length > 0 && data[0] && data[0].output) {
        // –ú–∞—Å—Å–∏–≤ –æ—Ç–≤–µ—Ç–æ–≤
        output = data[0].output;
        console.log("Found array response structure");
      } else if (data && !Array.isArray(data) && 'output' in data) {
        // –û–±—ä–µ–∫—Ç –æ—Ç–≤–µ—Ç–∞
        output = data.output;
        console.log("Found object response structure");
      }
      
      if (output) {
        console.log("Extracted output:", output);
        console.log("Message:", output.message);
        console.log("Suggestions:", output.suggestions);
        console.log("Parsed exercises:", output.parsed_exercises);
        console.log("Workout logged:", output.workout_logged);
        
        // –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å—Ä–∞–∑—É (—á–µ—Ä–µ–∑ 1 —Å–µ–∫—É–Ω–¥—É –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏)
        if (output.message) {
          console.log("Adding main message with delay");
          addMessageWithDelay(output.message, 1000);
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É –µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞
        if (output.workout_logged && output.parsed_exercises && output.parsed_exercises.length > 0) {
          console.log("üèãÔ∏è Saving workout data:", {
            userId: selectedUser.id,
            dayId: selectedDay.id,
            chatMessageId: userMessage.id,
            exercises: output.parsed_exercises
          });
          try {
            const savedWorkout = await workoutsApi.create(
              selectedUser.id,
              selectedDay.id,
              userMessage.id, // —Å–≤—è–∑—ã–≤–∞–µ–º —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
              output.parsed_exercises
            );
            console.log("‚úÖ Workout saved successfully:", savedWorkout);
            
            // –£–≤–µ–¥–æ–º–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö
            if (onWorkoutSaved) {
              onWorkoutSaved();
            }
          } catch (error) {
            console.error("‚ùå Error saving workout:", error);
          }
        } else {
          console.log("‚ÑπÔ∏è No workout to save:", {
            workout_logged: output.workout_logged,
            parsed_exercises: output.parsed_exercises
          });
        }
        
        // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if (output.suggestions && output.suggestions.length > 0) {
          console.log("Adding suggestions with delay");
          const suggestionsText = "üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n" + output.suggestions.map((s, i) => `${i + 1}. ${s}`).join("\n");
          addMessageWithDelay(suggestionsText, 6000); // 1 —Å–µ–∫ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–µ + 5 —Å–µ–∫ –æ–∂–∏–¥–∞–Ω–∏—è
        }
      } else {
        console.log("No valid data structure found in response");
        console.log("Data structure:", data);
        
        // Fallback –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        addMessageWithDelay("–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –≤ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook.", 1000);
      }
    } catch (error) {
      console.error("Error sending message:", error);
      
      // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ - –µ—Å–ª–∏ webhook –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–æ–∫–∞–∂–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç
      if (messageText.toLowerCase().includes("—Ç–µ—Å—Ç")) {
        addMessageWithDelay("–û—Ç–ª–∏—á–Ω–æ! –¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ üí™", 1000);
        addMessageWithDelay("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n1. –ü—Ä–æ–¥–æ–ª–∂–∞–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏\n2. –°–ª–µ–¥–∏ –∑–∞ –ø–∏—Ç–∞–Ω–∏–µ–º\n3. –ù–µ –∑–∞–±—ã–≤–∞–π –ø—Ä–æ –æ—Ç–¥—ã—Ö", 6000);
      } else {
        addMessageWithDelay("–ò–∑–≤–∏–Ω–∏, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ —Å–µ—Ä–≤–µ—Ä—É. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑!", 1000);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  if (!isInitialized) {
    return (
      <div className="flex flex-col h-full bg-white rounded-lg shadow-sm border border-primary-200">
        <div className="flex-1 flex items-center justify-center">
          <div className="text-primary-600">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full max-w-4xl mx-auto flex flex-col bg-white rounded-lg shadow-sm border border-primary-200">
      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-6 space-y-4" style={{ minHeight: 0 }}>
        <AnimatePresence>
          {messages.map((message) => (
            <motion.div
              key={message.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className={`flex ${message.isUser ? "justify-end" : "justify-start"}`}
            >
              <div
                className={`max-w-[80%] rounded-2xl px-4 py-3 ${
                  message.isUser
                    ? "text-white"
                    : "bg-primary-50 text-primary-900 border border-primary-200"
                }`}
                style={message.isUser ? { background: 'var(--gradient-accent)' } : {}}
              >
                <p className="whitespace-pre-line text-sm leading-relaxed">
                  {message.text}
                </p>
                <p className={`text-xs mt-2 opacity-70 ${message.isUser ? "text-white" : "text-primary-500"}`}>
                  {message.timestamp.toLocaleTimeString("ru-RU", {
                    hour: "2-digit",
                    minute: "2-digit",
                  })}
                </p>
              </div>
            </motion.div>
          ))}
        </AnimatePresence>
        
        {isLoading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="flex justify-start"
          >
            <div className="bg-primary-100 rounded-2xl px-4 py-3 flex items-center space-x-2">
              <Loader2 className="w-4 h-4 animate-spin text-primary-600" />
              <span className="text-sm text-primary-600">–ü–µ—á–∞—Ç–∞–µ—Ç...</span>
            </div>
          </motion.div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <div className="border-t border-primary-200 p-6 bg-gray-50/50">
        <div className="flex space-x-3">
          <div className="flex-1 relative">
            <textarea
              value={inputMessage}
              onChange={(e) => setInputMessage(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–≤–æ–µ–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ..."
              rows={1}
              className="w-full px-4 py-3 bg-primary-50 border border-primary-200 rounded-2xl resize-none focus:outline-none focus:ring-2 focus:ring-primary-600 focus:border-transparent text-sm text-primary-900"
              style={{
                minHeight: "48px",
                maxHeight: "120px",
              }}
            />
          </div>
          <button
            onClick={sendMessage}
            disabled={!inputMessage.trim() || isLoading}
            className="flex items-center justify-center w-12 h-12 text-white rounded-2xl hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
            style={{ background: 'var(--gradient-accent)' }}
          >
            <Send className="w-5 h-5" />
          </button>
        </div>
      </div>
    </div>
  );
}